### java中的内存分配
* 静态储存区：  
  编译时就分配好，在程序整个运行期间度存在。它主要存放静态数据和常量。
* 栈区：
  当方法执行时，会在栈区内存中创建方法体内部的局部变量，方法结束后自动释放内存。
* 堆区：
  通常存放new出来的对象，由Java垃圾回收器回收。

### 四种引用类型的介绍

*  强引用(StrongReference)：JVM 宁可抛出 OOM ，也不会让 GC 回收具有强引用的对象。
*  软引用(SoftReference)：只有在内存空间不足时，才会被回的对象。
*  弱引用(WeakReference)：在 GC 时，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。
*  虚引用(PhantomReference)：任何时候都可以被GC回收，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否将要被回收。可以用来作为GC回收Object的标志。我们常说的内存泄漏是指new出来的Object无法被GC回收，即为强引用。

### 内存抖动、内存溢出、内存泄漏
* 内存抖动  
  在极短的时间内，分配大量的内存，然后又释放它，这种现象就会造成内存抖动。典型地，在 View 控件的 onDraw 方法里分配大量内存，又释放大量内存，这种做法极易引起内存抖动，从而导致性能下降。因为 onDraw 里的大量内存分配和释放会给系统堆空间造成压力，触发 GC 工作去释放更多可用内存，而 GC 工作起来时，又会吃掉宝贵的帧时间 (帧时间是 16ms) ，最终导致性能问题。GC工作是发生在主线程中的，因为频繁的触发GC导致掉帧就是内存抖动。
* 内存溢出  
  每个Android应用程序都执行在自己的虚拟机中，每个虚拟机必定会有堆内存阈值限制（值得一提的是这个阈值一般都由厂商依据硬件配置及设备特性自己设定，没有统一标准，可以为64M，也可以为128M等；它的配置是在Android的属性系统的/system/build.prop中配置dalvik.vm.heapsize=128m即可，若存在dalvik.vm.heapstartsize则表示初始申请大小，也可以通过ActivityManager.getMemoryClass()获得这个值），也即一个应用进程同时存在的对象必须小于阈值规定的内存大小才可以正常运行，否则则会报oom（OutOfMemoryError）。产生的原因最直接的原因是一下子申请大量的内存超出阈值直接崩溃，还有原因是因为错误的程序导致内存泄漏，即使申请一小段内存也会直接崩溃。
* 内存泄漏  
内存泄漏是本该由GC回收的内存因为某些原因得不到回收而导致的，通俗的讲是本应该被回收的对象被比它生命周期还有长的对象持有，导致不可回收，就产生了内存泄漏。
